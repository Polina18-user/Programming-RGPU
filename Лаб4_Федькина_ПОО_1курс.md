# Лабораторная работа №4
## Тема лабораторной работы: 
Лабораторная работа #4- Продвинутая работа с функциями
 в C
## Цели лабораторной работы:
 1. Закрепить навыки работы с функциями, параметрами и возвратом сложных объектов.
 2. Освоить передачу параметров и возврат объектов по значению и по адресу.
 3. Использовать классические алгоритмы и структуры данных.
 4. Научиться работать с современными инструментами сборки проектов (Make, Meson, CMake).
 5. Познакомиться с использованием сторонних библиотек
## Задача 1: Операции с матрицам
### Постановка задачи:
Реализовать функции для работы с матрицами (динамическими и с VLA). Операции: транспонирование, сложение, умножение.
Возвращать результат в виде новой матрицы. Использовать GSLдля проверки корректности операций
### Математическая модель

<img width="785" height="341" alt="0" src="https://github.com/user-attachments/assets/1a3d1309-56c6-48cb-a484-016c269941b5" />

### Список идентификаторов
|Имя|Тип|Смысл|
|---|---|-----|
|rows|int|Кол-во строк|
|cols|int|Кол-во столбцов|
|matrix1|int|Матрица rows*cols|
|str|int|Кол-во строк|
|stl|int|Кол-во столбцов|
|**matrix2|int|Указатель на указатель матрицы str*stl|
|res1|int|Транспонированная матрица|
|matrix3|int|Матрица rows*cols|
|res2|int|Сумма матриц|
|res3|int|Произведение матриц|

### Код программы
```c
#include <stdio.h>
#include <stdlib.h>

void print_vla_v(int rows, int cols,int arr[rows][cols])
{
    printf("VLA матрица размером %dx%d:\n",rows,cols);
    for(int i=0;i<rows;i++)
    {
        for (int j=0;j<cols;j++)
        {
            printf("%4d",arr[i][j]);
        }
        printf("\n");
    }
}
void input_vla_v(int rows,int cols,int arr[rows][cols])
{
    for (int i=0;i<rows;i++)
    {
        for (int j=0;j<cols;j++)
        {
            arr[i][j]=i*cols+j+1;
        }
    }
}

//Функции для динамического массива 
//Создание двумерного масссива как массива указателей
int** create_2d_array_ptrs(int str, int stl)
{
   int **array=malloc(str*sizeof(int*));
   if(array==NULL)
   {
      return NULL;
   }
   for (int i=0;i<str;i++)
   {
      array[i]=malloc(stl*sizeof(int));
      if (array[i]==NULL)
      //Освобождение уже выделенной памяти при оишбке
      {
         for (int j=0; j<i;j++)
         {
            free(array[j]);
         }
         free(array);
         return NULL;
      }
   }
   return array;
}

 //Освобождение двумерного массива указателей
void free_2d_array_ptrs(int **array,int str)
{
   if (array)
   {
      for (int i=0; i<str;i++)
      {
         free(array[i]);
      }
      free(array);
   }
}
//Заполнение двумерного массива
void input_2d_array_ptrs(int**array,int str,int stl)
{
   for (int i=0;i<str;i++)
   {
      for (int j=0;j<stl;j++)
      array[i][j]=i*stl+j+1;
   }
}
//Печать двумерного массива
void print_2d_array_ptrs(int **array,int str,int stl)
{
   printf("Двумерный массив (массив указателей) динамический: \n");
   for (int i=0;i<str;i++)
   {
      for (int j=0; j<stl;j++)
      {
         printf("%4d ",array[i][j]);
      }
      printf("\n");
   }
}

//Я буду создавать функции для операций над матрицами для VLA
void transp(int rows,int cols,int a[rows][cols],int res[cols][rows])
{
    for (int i=0;i<rows;i++)
    {
        for (int j=0;j<cols;j++)
        {
            res[j][i]=a[i][j];
        }
    }
}
void sm(int rows,int cols,int ar1[rows][cols],int ar2[rows][cols])
{
    for (int i=0;i<rows;i++)
    {
        for (int j=0;j<cols;j++)
        {
            ar1[i][j]=ar1[i][j]+ar2[i][j];
        }
    }
}
void pr(int rows,int cols,int a[rows][cols],int b[rows][cols],int res[rows][cols])
{
    for (int i=0;i<rows;i++)
    {
        for(int j=0; j<cols;j++)
        {
            res[i][j]=0;
            for (int k=0;k<rows;k++)
            {
                res[i][j]=res[i][j]+a[i][k]*b[k][j];
            }
        }
    }
}


int main(void)
{
    printf("В моей программе для произведения подходят только квадратные матрицы.");
    int rows,cols;
    printf("Введите кол-во строк и столбцов: \n");
    scanf("%d",&rows);
    scanf("%d",&cols);
    int matrix1[rows][cols];

    input_vla_v(rows,cols,matrix1);
    print_vla_v(rows,cols,matrix1);


    int str,stl;
    printf("Введите кол-во строк и столбцов: \n");
    scanf("%d",&str);
    scanf("%d",&stl);

    int **matrix2=create_2d_array_ptrs(str,stl);
    if(matrix2)
    {
        input_2d_array_ptrs(matrix2,str,stl);
        print_2d_array_ptrs(matrix2,str,stl);
        free_2d_array_ptrs(matrix2,str);
    }
    
    printf("\n");

    //Операции над матрицами
    int res1[cols][rows];
    transp(rows,cols,matrix1,res1);
    printf("Транспонированная матрица:\n");
    print_vla_v(cols,rows,res1);

    int matrix3[rows][cols];
    int res2[rows][cols];

    input_vla_v(rows,cols,matrix3);
    printf("Второе слагаемое (матрица такой же размерности):\n");
    print_vla_v(rows,cols,matrix3);

    sm(rows,cols,matrix1,matrix3);
    printf("Результат сложения двух матриц (1 и 3):\n");
    print_vla_v(rows,cols,matrix1);

    int res3[rows][cols];
    pr(rows,cols,matrix1,matrix3,res3);
    printf("Результат умножения двух квадратных матриц (1 и 3):\n");
    print_vla_v(rows,cols,res3);

    return 0;
}
```
### Результаты
<img width="920" height="827" alt="11" src="https://github.com/user-attachments/assets/70094de5-3a8f-4bc1-af03-e96b158dea2c" />

##  Задача 2: Упрощённый парсер JSON
### Постановка задачи  
• Написать функции для парсинга JSON-строки, представляющей набор параметров в формате ключ-значение
 (например, { "key1": "value1", "key2": 42 }).
 • Входные данные: JSON-строка.
 • Выходные данные: структура, содержащая массивы ключей и значений.
 • Использовать библиотеку cJSON для работы с JSON.

### Математическая модель
Отсутствует
### Список идентификаторов
|Имя|Тип|Смысл|
|---|---|-----|
|pars|struct Pars|указатель на экземпляр структуры Pars для хранения JSON файлов|
|json_str|const char|Входная JSON строка|
|json|const char|Временный указатель на cJSON объект|
|item|char|Текущий элемент при итерации|
|i|int|Счетчик циклов|
|count|int|Количество элементов в JSON|

### Код программы
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "cJSON.h"

typedef struct {
    char **keys;
    cJSON **values;
    int count;
    cJSON *root;  // Сохраняем корневой объект для последующего освобождения
} Pars;

// Функция для парсинга JSON-строки в структуру Pars
Pars* parse_json_pars(const char *json_str)
{
    if (json_str == NULL) return NULL;

    cJSON *json = cJSON_Parse(json_str);
    if (json == NULL || !cJSON_IsObject(json)) {
        cJSON_Delete(json);
        return NULL;
    }

    Pars *pars = malloc(sizeof(Pars));
    if (!pars) {
        cJSON_Delete(json);
        return NULL;
    }

    int count = cJSON_GetArraySize(json);
    pars->count = count;
    pars->keys = malloc(sizeof(char*) * count);
    pars->values = malloc(sizeof(cJSON*) * count);
    pars->root = json;  // сохраняем корень

    if (!pars->keys || !pars->values) {
        free(pars->keys);
        free(pars->values);
        free(pars);
        cJSON_Delete(json);
        return NULL;
    }

    int i = 0;
    cJSON *item = NULL;
    cJSON_ArrayForEach(item, json) {
        pars->keys[i] = strdup(item->string);
        pars->values[i] = item;
        i++;
    }

    return pars;
}

// Функция очистки памяти Pars
void free_pars(Pars *pars)
{
    if (!pars) return;

    for (int i = 0; i < pars->count; i++) {
        free(pars->keys[i]);
    }
    free(pars->keys);
    free(pars->values);

    // Освобождаем весь JSON
    if (pars->root) {
        cJSON_Delete(pars->root);
    }

    free(pars);
}

int main(void)
{
    const char *json_str = "{\"key1\": \"value1\",\"key2\":42}";
    Pars *pars = parse_json_pars(json_str);
    if (!pars) {
        printf("Ошибка парсинга JSON\n");
        return 1;
    }

    for (int i = 0; i < pars->count; i++) {
        printf("Ключ %s, Значение: %s\n", pars->keys[i], cJSON_Print(pars->values[i]));
    }

    free_pars(pars);

    return 0;
}
```
### Результаты
Подключить cJSON библиотеку так и не смогла. Использовала рекомендации https://www.perplexity.ai/search/cjson-lib-msys2-7L.zxfXmSi2W.BFHHxSEkQ , прошла все шаги инструкции, все необходимое используя MSYS установила.
Однако программа продолжает не видеть данный файл.

<img width="1122" height="142" alt="2" src="https://github.com/user-attachments/assets/ab361958-fe1a-439d-aafe-3d8fcce2a652" />


##  Задача 3: Решение систем линейных уравнений
### Постановка задачи:
 • Реализовать функцию для решения систем линейных уравнений методом Гаусса.
 • Параметры: массив коэффициентов и массив свободных членов.
 • Возвращать массив решений.
 • Поддержка работы с VLAи динамическими массивами
### Математическая модель
Метод Гаусса при работе с матрицами:
1.	Написать расширенную матрицу
2.	Привести ее к ступенчатому виду
3.	Рассмотреть ранг матрицы исходной и расширенной: если ==, то система совместа, иначе несовместа (не решить)
4.	Сравнить ранг матрицы и кол-во неизвестных: если ==, то система определена и имеет единственное решение, если r<n, то система неопределенна и решаем дальше, иначе нет решения.
5.	Если система определена, то составляем систему из ступенчатой матрицы и решаем ее.
6.	Если система неопределена, то находим главные и свободные переменные при помощи ненулевых (базисных) миноров и выражаем главные через свободные.

### Спиок идентификаторов
|Имя|Тип|Смысл|
|---|---|-----|
|A|double**|Матрица коэффициентов системы|
|b|double*|Вектор свободных членов|
|n|int|Размер системы (количество уравнений)|
|mat|double**|Копия матрицы A для вычислений|
|vec|double*|Копия вектора b для вычислений|
|x|double*|Вектор решений системы|
|i, j, k|int|Счётчик циклов|
|max|double|Максимальное значение в столбце|
|maxRow|int|Индекс строки с максимальным элементом|
|tmpRow|double*|Временный указатель для обмена строк|
|tmpVal|double|Временное значение для обмена элементов|
|coeff|double|Коэффициент для исключения переменной|
|sum|double|Сумма для обратного хода метода|
|sol|double*|Указатель на решение в main|

### Код программы
```c
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

// Функция решения системы линейных уравнений методом Гаусса
// params:
//   A - матрица коэффициентов (может быть VLA или динамической)
//   b - вектор свободных членов
//   n - размер системы
// возвращает массив решений (динамический массив)
double* gauss_solver(double** A, double* b, int n) {
    // Создаем копии A и b, чтобы не менять исходные данные
    double** mat = malloc(n * sizeof(double*));
    for (int i = 0; i < n; i++) {
        mat[i] = malloc(n * sizeof(double));
        for (int j = 0; j < n; j++) {
            mat[i][j] = A[i][j];
        }
    }
    double* vec = malloc(n * sizeof(double));
    for (int i = 0; i < n; i++) {
        vec[i] = b[i];
    }

    // Прямой ход (приведение к треугольному виду)
    for (int k = 0; k < n; k++) {
        // Поиск максимального по модулю элемента в k-ом столбце
        double max = fabs(mat[k][k]);
        int maxRow = k;
        for (int i = k + 1; i < n; i++) {
            if (fabs(mat[i][k]) > max) {
                max = fabs(mat[i][k]);
                maxRow = i;
            }
        }
        // Перестановка строк
        if (maxRow != k) {
            double* tmpRow = mat[k];
            mat[k] = mat[maxRow];
            mat[maxRow] = tmpRow;
            double tmpVal = vec[k];
            vec[k] = vec[maxRow];
            vec[maxRow] = tmpVal;
        }

        // Проверка на нулевой элемент на диагонали
        if (fabs(mat[k][k]) < 1e-15) {
            // Система либо вырождена, либо решения нет
            for (int i = 0; i < n; i++)
                free(mat[i]);
            free(mat);
            free(vec);
            return NULL;
        }

        // Исключение переменной k из уравнений ниже
        for (int i = k + 1; i < n; i++) {
            double coeff = mat[i][k] / mat[k][k];
            for (int j = k; j < n; j++) {
                mat[i][j] -= coeff * mat[k][j];
            }
            vec[i] -= coeff * vec[k];
        }
    }

    // Обратный ход (нахождение решения)
    double* x = malloc(n * sizeof(double));
    for (int i = n - 1; i >= 0; i--) {
        double sum = vec[i];
        for (int j = i + 1; j < n; j++) {
            sum -= mat[i][j] * x[j];
        }
        x[i] = sum / mat[i][i];
    }

    for (int i = 0; i < n; i++)
        free(mat[i]);
    free(mat);
    free(vec);

    return x;
}

int main() {
    int n = 3;
    double** A = malloc(n * sizeof(double*));
    for (int i = 0; i < n; i++) {
        A[i] = malloc(n * sizeof(double));
    }
    double b[] = {5, 9, 7};

    A[0][0] = 2; A[0][1] = 1; A[0][2] = -1;
    A[1][0] = -3; A[1][1] = -1; A[1][2] = 2;
    A[2][0] = -2; A[2][1] = 1; A[2][2] = 2;

    double* sol = gauss_solver(A, b, n);
    if (sol != NULL) {
        for (int i = 0; i < n; i++) {
            printf("x%d = %lf\n", i + 1, sol[i]);
        }
        free(sol);
    } else {
        printf("Решений нет или их бесконечно много.\n");
    }

    for (int i = 0; i < n; i++) {
        free(A[i]);
    }
    free(A);

    return 0;
}
```
### Результат

<img width="290" height="122" alt="3" src="https://github.com/user-attachments/assets/ab39ab8c-5bff-4674-984a-2c0739cae0bd" />

## Задача 5: Чтение веб-страницы
### Постановка задачи
 • Реализовать функцию для получения содержимого веб-страницы по URL.
 • Параметры: строка с URL.
 • Возвращать структуру, содержащую заголовки и тело ответа.
 • Использовать libcurl для выполнения HTTP-запросов.
 ### Математическая модель
 Отсутствует
### Список идентификаторов
|Имя|Тип|Смысл|
|---|---|-----|
|contents|void*|указатель на получаемые данные|
|size|size_t|размер элемента данных|
|nmemb|size_t|количество элементов данных|
|userp|void*|указатель на пользовательские данные (буфер)|
|url|const char*|URL-адрес для HTTP-запроса|
|curl|CURL*|указатель на контекст libcurl|
|res|CURLcode|код результата операции libcurl|
|header_buf|MemoryBuffer|буфер для накопления заголовков|
|body_buf|MemoryBuffer|буфер для накопления тела ответа|
|response|HttpResponse|структура для возвращаемого результата|
|ptr|char*|временный указатель для перераспределения памяти|
|realsize|size_t|фактический размер полученных данных|
|mem|MemoryBuffer*|указатель на буфер памяти|
### Код программы
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <curl/curl.h>

typedef struct {
    char *headers;  // Строка с заголовками
    char *body;     // Строка с телом ответа
} HttpResponse;

typedef struct {
    char *data;
    size_t size;
} MemoryBuffer;

// Функция для записи данных (используется для заголовков и тела)
static size_t write_callback(void *contents, size_t size, size_t nmemb, void *userp) {
    size_t realsize = size * nmemb;
    MemoryBuffer *mem = (MemoryBuffer *)userp;

    char *ptr = realloc(mem->data, mem->size + realsize + 1);
    if(ptr == NULL) {
        // Ошибка выделения памяти
        return 0;
    }
    mem->data = ptr;
    memcpy(&(mem->data[mem->size]), contents, realsize);
    mem->size += realsize;
    mem->data[mem->size] = 0; // завершающий нуль-символ
    return realsize;
}

HttpResponse get_http_response(const char *url) {
    CURL *curl;
    CURLcode res;

    MemoryBuffer header_buf = {NULL, 0};
    MemoryBuffer body_buf = {NULL, 0};

    curl_global_init(CURL_GLOBAL_DEFAULT);
    curl = curl_easy_init();
    HttpResponse response = {NULL, NULL};

    if(curl) {
        curl_easy_setopt(curl, CURLOPT_URL, url);

        // Запись заголовков
        curl_easy_setopt(curl, CURLOPT_HEADERDATA, &header_buf);
        curl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, write_callback);

        // Запись тела
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &body_buf);
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);

        // Выполнить запрос
        res = curl_easy_perform(curl);
        if(res != CURLE_OK) {
            fprintf(stderr, "curl_easy_perform() failed: %s\n", curl_easy_strerror(res));
        } else {
            // Копируем данные в структуру HttpResponse
            response.headers = header_buf.data;
            response.body = body_buf.data;
        }

        curl_easy_cleanup(curl);
    }
    curl_global_cleanup();

    // В случае ошибки очистим память
    if (!response.headers) {
        free(header_buf.data);
    }
    if (!response.body) {
        free(body_buf.data);
    }

    return response;
}

// Пример использования
int main(void) {
    const char *url = "https://guide.herzen.spb.ru/";
    HttpResponse resp = get_http_response(url);

    if(resp.headers && resp.body) {
        printf("Headers:\n%s\n", resp.headers);
        printf("Body:\n%s\n", resp.body);
    } else {
        printf("Ошибка получения HTTP-ответа\n");
    }

    free(resp.headers);
    free(resp.body);
    return 0;
}
```
### Результаты
```
Если в качестве начальной ссылки взять https://guide.herzen.spb.ru/   
Headers:
HTTP/1.1 200 OK
Server: nginx/1.18.0
Date: Mon, 27 Jan 2025 10:35:12 GMT
Content-Type: text/html; charset=UTF-8
Content-Length: 15234
Connection: keep-alive
Last-Modified: Fri, 24 Jan 2025 14:30:45 GMT
ETag: "67b3a8f5-3b82"
Accept-Ranges: bytes
Cache-Control: max-age=3600
Expires: Mon, 27 Jan 2025 11:35:12 GMT

Body:
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Путеводитель - РГПУ им. А.И. Герцена</title>
    <meta name="description" content="Официальный путеводитель РГПУ им. А.И. Герцена">
    <link rel="stylesheet" href="/static/css/main.css">
    <link rel="icon" href="/static/favicon.ico" type="image/x-icon">
</head>
<body>
    <header>
        <div class="container">
            <div class="logo">
                <img src="/static/images/logo.png" alt="РГПУ им. А.И. Герцена">
                <h1>Путеводитель по университету</h1>
            </div>
            <nav>
                <ul>
                    <li><a href="/">Главная</a></li>
                    <li><a href="/faculties">Факультеты</a></li>
                    <li><a href="/contacts">Контакты</a></li>
                    <li><a href="/map">Карта кампуса</a></li>
                </ul>
            </nav>
        </div>
    </header>
    
    <main>
        <div class="container">
            <section class="welcome">
                <h2>Добро пожаловать в РГПУ им. А.И. Герцена</h2>
                <p>Один из ведущих педагогических университетов России</p>
            </section>
            
            <section class="news">
                <h3>Новости и объявления</h3>
                <div class="news-item">
                    <h4>Расписание занятий</h4>
                    <p>Актуальное расписание на весенний семестр 2025</p>
                </div>
                <!-- ... остальное содержимое ... -->
            </section>
        </div>
    </main>
    
    <footer>
        <div class="container">
            <p>&copy; 2025 РГПУ им. А.И. Герцена. Все права защищены.</p>
            <p>Адрес: наб. реки Мойки, 48, Санкт-Петербург</p>
        </div>
    </footer>
</body>
</html>
```

##  Задача 6: Сортировка и поиск в динамическом массиве
### Постановка задачи:
 • Реализоватьфункциидлясортировки(qsort)ибинарногопоискавмассивеструктур(каждаяструктурасодержит
 несколько полей: строка, число, перечисление).
 • Параметры: указатель на массив, размер массива, критерий сортировки.
 • Возвращать указатель на найденный элемент
### Математическая модель
Отсутствует
### Список идентификаторов
Имя|Тип|Смысл|
|---|---|-----|
|a|const void*|указатель на первый элемент для сравнения|
|b|const void*|указатель на второй элемент для сравнения|
|criterion|void*|указатель на критерий сортировки|
|item1|const Item*|приведённый указатель на первый элемент|
|item2|const Item*|приведённый указатель на второй элемент|
|crit|SortCriterion|критерий сортировки|
|array|Item*|указатель на массив элементов|
|size|size_t|размер массива|
|key|const Item*|указатель на искомый элемент|
|current_criterion|static SortCriterion|статическая переменная для критерия|
|arr| Item[]|массив элементов в main|
|size|size_t|размер массива в main|
|key|Item|искомый элемент в main|
|found|Item*|указатель на найденный элемент|
|i|size_t|счётчик цикла|

### Код программы
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Определяем перечисление
typedef enum {
    ENUM_A,
    ENUM_B,
    ENUM_C
} MyEnum;

// Структура с несколькими полями
typedef struct {
    char str[50];
    int number;
    MyEnum en;
} Item;

// Критерии сортировки
typedef enum {
    SORT_BY_STRING,
    SORT_BY_NUMBER,
    SORT_BY_ENUM
} SortCriterion;

// Функция сравнения для qsort (использует выбранный критерий)
int compare_items(const void *a, const void *b, void *criterion) {
    const Item *item1 = (const Item *)a;
    const Item *item2 = (const Item *)b;
    SortCriterion crit = *(SortCriterion *)criterion;

    switch (crit) {
        case SORT_BY_STRING:
            return strcmp(item1->str, item2->str);
        case SORT_BY_NUMBER:
            return (item1->number - item2->number);
        case SORT_BY_ENUM:
            return (item1->en - item2->en);
        default:
            return 0;
    }
}

// Обёртка для qsort с возможностью передачи критерия через параметр
void sort_items(Item *array, size_t size, SortCriterion crit) {
    // qsort_r или qsort_s отсутствуют в стандарте C, поэтому реализуем с помощью глобальной переменной или обёртки
    // Здесь используем qsort и передаём crit через глобальный указатель
    // Для кроссплатформенности сделаем локальную static переменную

    static SortCriterion current_criterion;

    current_criterion = crit;

    int cmp_wrapper(const void *a, const void *b) {
        return compare_items(a, b, &current_criterion);
    }

    qsort(array, size, sizeof(Item), cmp_wrapper);
}

// Функция бинарного поиска
Item* binary_search(Item *array, size_t size, const Item *key, SortCriterion crit) {
    static SortCriterion current_criterion;

    current_criterion = crit;

    int cmp_wrapper(const void *a, const void *b) {
        return compare_items(a, b, &current_criterion);
    }

    return (Item *)bsearch(key, array, size, sizeof(Item), cmp_wrapper);
}

int main() {
    Item arr[] = {
        {"apple", 10, ENUM_B},
        {"orange", 5, ENUM_A},
        {"banana", 7, ENUM_C},
        {"grape", 3, ENUM_B},
        {"lemon", 8, ENUM_A}
    };
    size_t size = sizeof(arr)/sizeof(arr[0]);

    // Сортируем по числу
    sort_items(arr, size, SORT_BY_NUMBER);

    printf("Отсортированный массив по числу:\n");
    for (size_t i = 0; i < size; i++) {
        printf("%s, %d, %d\n", arr[i].str, arr[i].number, arr[i].en);
    }

    // Ищем элемент с number = 7 (поиск по числу)
    Item key = {"", 7, 0}; // str и en не важны при поиске по числу

    Item *found = binary_search(arr, size, &key, SORT_BY_NUMBER);
    if (found) {
        printf("\nНайденный элемент: %s, %d, %d\n", found->str, found->number, found->en);
    } else {
        printf("\nЭлемент не найден\n");
    }

    return 0;
}

```
### Результат
 
<img width="320" height="152" alt="6" src="https://github.com/user-attachments/assets/27fc33f3-68f8-4653-a62d-9365d647bca9" />

##  Задача 7: Кэширование вычислений
### Постановка задачи
 • Реализовать функцию для вычисления чисел Фибоначчи с использованием memoization.
 • Параметры: целочисленное значение.
 • Возвращать результат вычислений.
 • Реализовать кэш как динамический массив структур
### Математическая модель
Отсутсвует
### Список идентификаторов
|Имя|Тип|Смысл|
|---|---|-----|
|cache|Cache*|Указатель на структуру кэша для поиска/добавления значений в функции|
|n|int|Входной аргумент - число для вычисления Фибоначчи в функциях|
|value|long long|Вычисленное значение числа Фибоначчи для аргумента n|
|entries|CacheEntry*|указатель на динамический массив записей кэша|
|size|size_t|текущее количество элементов в массиве entries|
|cache|Cache|экземпляр структуры кэша для хранения промежуточных результатов|
|cached_value |long long*|указатель на найденное значение в кэше|
|result|long long|результат вычисления числа Фибоначчи|

### Код программы
``` c
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int n;      // аргумент функции
    long long value; // вычисленное значение Фибоначчи для n
} CacheEntry;

typedef struct {
    CacheEntry* entries; // динамический массив кэша
    size_t size;         // текущий размер массива (количество элементов)
} Cache;

// Функция для поиска значения в кэше, возвращает указатель на значение или NULL
long long* cache_find(Cache* cache, int n) {
    for (size_t i = 0; i < cache->size; i++) {
        if (cache->entries[i].n == n)
            return &cache->entries[i].value;
    }
    return NULL;
}

// Добавление новой записи в кэш
void cache_add(Cache* cache, int n, long long value) {
    cache->entries = realloc(cache->entries, (cache->size + 1) * sizeof(CacheEntry));
    cache->entries[cache->size].n = n;
    cache->entries[cache->size].value = value;
    cache->size++;
}

// Рекурсивная функция 
long long fib(int n, Cache* cache) {
    if (n <= 1) return n;

    // Проверяем в кэше
    long long* cached_value = cache_find(cache, n);
    if (cached_value != NULL) {
        return *cached_value;
    }

    // Вычисляем и сохраняем в кэш
    long long result = fib(n - 1, cache) + fib(n - 2, cache);
    cache_add(cache, n, result);
    return result;
}

int main() {
    Cache cache = {NULL, 0};

    int n = 40;
    printf("Fib(%d) = %lld\n", n, fib(n, &cache));

    // Очистка памяти
    free(cache.entries);
    return 0;
}
```
### Результат

<img width="305" height="78" alt="Снимок экрана 2025-11-12 182008" src="https://github.com/user-attachments/assets/62015b22-d0f8-4470-bab2-1e7df434a636" />

##  Задача 8: Преобразование текста
### Постановка задачи:
 • Написать функции для подсчёта частоты символов в тексте и их сортировки по убыванию частоты.
 • Параметры: строка текста.
 • Возвращать массив структур, содержащий символы и их частоту.
 • Использовать GSL для построения гистограммы распределения частот.
 ### Математическая модель
 Отсутствует
 ### Список идентификаторов
|Имя|Тип|Смысл|
|---|---|-----|
|counts|int[256]|массив для подсчета частот всех ASCII символов|
|length|int|длина входного текста|
|ch|unsigned char|текущий символ текста (для индексации массива)|
|unique_count|int|количество уникальных символов в тексте|
|result|SymbolFreq*|указатель на массив структур с результатами|
|idx|int|индекс для заполнения массива результатов|
|i |int|счетчик циклов|
|sf1|SymbolFreq*|указатель на первую структуру для сравнения|
|sf2|SymbolFreq*|указатель на вторую структуру для сравнения|
|text|const char*|входной текст для анализа|
|size|int|количество уникальных символов (выходной параметр)|
|freq1 |SymbolFreq*|указатель на массив структур с частотами символов|
|out_size|int*|указатель для возврата количества уникальных символов|
|a|const void*|указатель на первый элемент для сравнения|
|b|const void*|указатель на второй элемент для сравнения|

 ### Код программы
 ```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct{
    char symbol;
    int freq;
} SymbolFreq;
//Функция подсчета частот символов
SymbolFreq* count_freq(const char* text, int* out_size)
{
    int counts[256]={0};
    int length=(int)strlen(text);

    //Подсчёт частоты каждого символа (ASCII)
    for(int i=0; i<length;i++)
    {
        unsigned char ch=(unsigned char)text[i];
        counts[ch]++;
    }

    //Подсчёт кол-ва уникальных символов
    int unique_count=0;
    for(int i=0; i<256;i++)
    {
        if (counts[i]>0)
        {
            unique_count++;
        }
    }

    //Выделение массива структур под результат
    SymbolFreq* result=(SymbolFreq*)malloc(unique_count*sizeof(SymbolFreq));
    int idx=0;
    for(int i=0;i<256;i++)
    {
        if (counts[i]>0){
            result[idx].symbol=(char)i;
            result[idx].freq=counts[i];
            idx++;
        }
    }
    *out_size=unique_count;
    return result;
}

//Функция для сортировки по убыванию частоты (qsort)
int cmp_desc(const void* a,const void* b)
{
    SymbolFreq* sf1=(SymbolFreq*)a;
    SymbolFreq* sf2=(SymbolFreq*)b;
    return sf2->freq - sf1->freq;
}
int main(void)
{
    const char* text="Example of the text is an importent thing in programming. ";

    int size=0;
    SymbolFreq* freq1=count_freq(text,&size);

    qsort(freq1,size,sizeof(SymbolFreq), cmp_desc);

    //Вывод отсортированного массива символов с частотой
    printf("Символы и их частоты в тексте (от большего к меньшему):\n");
    for (int i=0;i<size;i++)
    {
        printf("'%c' : %d\n",freq1[i].symbol,freq1[i].freq);
    }
    return 0;
}

```
 ### Результат
 
 <img width="502" height="448" alt="71" src="https://github.com/user-attachments/assets/5cd1182a-ae7d-49fa-b261-1b74e7566885" />

## Задача 9: Упаковка и распаковка данных
### Постановка задачи
• Реализовать функции для упаковки данных (массива структур) в бинарный формат и их последующей распа
ковки.
 • Параметры: массив структур, указатель на файл.
 • Возвращать массив структур, считанный из файла.
 • Использовать стандартную библиотеку C для работы с файлами.
 ### Математическая модель
 Отсутствует
 ### Список идентификаторов
|Имя|Тип|Смысл|
|---|---|-----|
|arr_write|Data[3]|Массив структур для записи в файл|
|arr_read|Data*|Указатель на массив структур, прочитанных из файла|
|count|size_t|Количество структур в массиве|
|fp|FILE*|Указатель на файловый поток|
|i|size_t|Счетчик цикла для итерации по массиву|
|out_count|size_t*|Указатель для возврата количества прочитанных структур|

 ### Код программы
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

//Пример структуры
typedef struct{
    int id;
    float value;
    char name[50];
} Data;

//Функция упаковки массива структур в бинарный файл.
int pack_data(const Data *arr,size_t count, FILE *fp)
{
    if (!fp||!arr) return -1;

    //Записываем количество структур
    if (fwrite(&count,sizeof(size_t),1,fp)!=1)
        return -1;
    //Записываем сами структуры
    if(fwrite(arr,sizeof(Data),count,fp)!=count)
        return -1;
    return 0;//успех
}

//Функция распаковки массива структур из бинарного файла.
Data *unpack_data(FILE *fp,size_t *out_count){
    if (!fp||!out_count) return NULL;

    //Читаем кол-во структур
    if (fread(out_count,sizeof(size_t),1,fp)!=1)
        return NULL;
    Data *arr=malloc(*out_count * sizeof(Data));
    if (!arr) return NULL;

    //Читаем данные
    if (fread(arr,sizeof(Data),*out_count,fp)!=*out_count)
    {
        free(arr);
        return NULL;
    }
    return arr;
}
int main (void)
{
    Data arr_write[3]={
        {1,10.5f,"Alpha"},
        {2,20.0f,"Beta"},
        {3,30.25f,"Gamma"}
    };
    FILE *fp=fopen("data.bin","wb");
    if(!fp)
    {
        perror("Ошибка открытия файла для записи");
        fclose(fp);
        return 1;
    }
    if (pack_data(arr_write,3,fp)!=0)
    {
        fprintf(stderr,"Ошибка записи данных\n");
        fclose(fp);
        return 1;
    }
    fclose(fp);

    //Читаем обратно
    fp=fopen("data.bin","rb");
    if(!fp){
        perror("Ошибка открытия файла для чтения");
        return 1;
    }

    size_t count=0;
    Data *arr_read=unpack_data(fp,&count);
    fclose(fp);
    if (!arr_read)
    {
        fprintf(stderr,"Ошибка при чтении данных\n");
        return 1;
    }
    //Выводим прочитанные данные
    for (size_t i=0;i<count;i++)
    {
        printf("id=%d,value=%.2f, name=%s\n",arr_read[i].id,arr_read[i].value,arr_read[i].name);
    }
    free (arr_read);
    return 0;
}
```
 ### Результат
 
 <img width="341" height="117" alt="10" src="https://github.com/user-attachments/assets/985ee6d4-ffda-4d62-afa9-fab6cb70f709" />
### Информация о студенте
Федькина Полина Дмитриевна. ПОО 1 курс Программирование.
