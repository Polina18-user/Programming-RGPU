# Лабораторная работа №4
## Тема лабораторной работы: 
Лабораторная работа #4- Продвинутая работа с функциями
 в C
## Цели лабораторной работы:
 1. Закрепить навыки работы с функциями, параметрами и возвратом сложных объектов.
 2. Освоить передачу параметров и возврат объектов по значению и по адресу.
 3. Использовать классические алгоритмы и структуры данных.
 4. Научиться работать с современными инструментами сборки проектов (Make, Meson, CMake).
 5. Познакомиться с использованием сторонних библиотек
## Задача 1: Операции с матрицам
### Постановка задачи:
Реализовать функции для работы с матрицами (динамическими и с VLA). Операции: транспонирование, сложение, умножение.
Возвращать результат в виде новой матрицы. Использовать GSLдля проверки корректности операций
### Математическая модель

<img width="785" height="341" alt="0" src="https://github.com/user-attachments/assets/1a3d1309-56c6-48cb-a484-016c269941b5" />

### Список идентификаторов
|Имя|Тип|Смысл|
||||

### Код программы
```c
#include <stdio.h>
#include <stdlib.h>

void print_vla_v(int rows, int cols,int arr[rows][cols])
{
    printf("VLA матрица размером %dx%d:\n",rows,cols);
    for(int i=0;i<rows;i++)
    {
        for (int j=0;j<cols;j++)
        {
            printf("%4d",arr[i][j]);
        }
        printf("\n");
    }
}
void input_vla_v(int rows,int cols,int arr[rows][cols])
{
    for (int i=0;i<rows;i++)
    {
        for (int j=0;j<cols;j++)
        {
            arr[i][j]=i*cols+j+1;
        }
    }
}

//Функции для динамического массива 
//Создание двумерного масссива как массива указателей
int** create_2d_array_ptrs(int str, int stl)
{
   int **array=malloc(str*sizeof(int*));
   if(array==NULL)
   {
      return NULL;
   }
   for (int i=0;i<str;i++)
   {
      array[i]=malloc(stl*sizeof(int));
      if (array[i]==NULL)
      //Освобождение уже выделенной памяти при оишбке
      {
         for (int j=0; j<i;j++)
         {
            free(array[j]);
         }
         free(array);
         return NULL;
      }
   }
   return array;
}

 //Освобождение двумерного массива указателей
void free_2d_array_ptrs(int **array,int str)
{
   if (array)
   {
      for (int i=0; i<str;i++)
      {
         free(array[i]);
      }
      free(array);
   }
}
//Заполнение двумерного массива
void input_2d_array_ptrs(int**array,int str,int stl)
{
   for (int i=0;i<str;i++)
   {
      for (int j=0;j<stl;j++)
      array[i][j]=i*stl+j+1;
   }
}
//Печать двумерного массива
void print_2d_array_ptrs(int **array,int str,int stl)
{
   printf("Двумерный массив (массив указателей) динамический: \n");
   for (int i=0;i<str;i++)
   {
      for (int j=0; j<stl;j++)
      {
         printf("%4d ",array[i][j]);
      }
      printf("\n");
   }
}

//Я буду создавать функции для операций над матрицами для VLA
void transp(int rows,int cols,int a[rows][cols],int res[cols][rows])
{
    for (int i=0;i<rows;i++)
    {
        for (int j=0;j<cols;j++)
        {
            res[j][i]=a[i][j];
        }
    }
}
void sm(int rows,int cols,int ar1[rows][cols],int ar2[rows][cols])
{
    for (int i=0;i<rows;i++)
    {
        for (int j=0;j<cols;j++)
        {
            ar1[i][j]=ar1[i][j]+ar2[i][j];
        }
    }
}
void pr(int rows,int cols,int a[rows][cols],int b[rows][cols],int res[rows][cols])
{
    for (int i=0;i<rows;i++)
    {
        for(int j=0; j<cols;j++)
        {
            res[i][j]=0;
            for (int k=0;k<rows;k++)
            {
                res[i][j]=res[i][j]+a[i][k]*b[k][j];
            }
        }
    }
}


int main(void)
{
    printf("В моей программе для произведения подходят только квадратные матрицы.");
    int rows,cols;
    printf("Введите кол-во строк и столбцов: \n");
    scanf("%d",&rows);
    scanf("%d",&cols);
    int matrix1[rows][cols];

    input_vla_v(rows,cols,matrix1);
    print_vla_v(rows,cols,matrix1);


    int str,stl;
    printf("Введите кол-во строк и столбцов: \n");
    scanf("%d",&str);
    scanf("%d",&stl);

    int **matrix2=create_2d_array_ptrs(str,stl);
    if(matrix2)
    {
        input_2d_array_ptrs(matrix2,str,stl);
        print_2d_array_ptrs(matrix2,str,stl);
        free_2d_array_ptrs(matrix2,str);
    }
    
    printf("\n");

    //Операции над матрицами
    int res1[cols][rows];
    transp(rows,cols,matrix1,res1);
    printf("Транспонированная матрица:\n");
    print_vla_v(cols,rows,res1);

    int matrix3[rows][cols];
    int res2[rows][cols];

    input_vla_v(rows,cols,matrix3);
    printf("Второе слагаемое (матрица такой же размерности):\n");
    print_vla_v(rows,cols,matrix3);

    sm(rows,cols,matrix1,matrix3);
    printf("Результат сложения двух матриц (1 и 3):\n");
    print_vla_v(rows,cols,matrix1);

    int res3[rows][cols];
    pr(rows,cols,matrix1,matrix3,res3);
    printf("Результат умножения двух квадратных матриц (1 и 3):\n");
    print_vla_v(rows,cols,res3);

    return 0;
}
```
### Результаты
<img width="920" height="827" alt="11" src="https://github.com/user-attachments/assets/70094de5-3a8f-4bc1-af03-e96b158dea2c" />

##  Задача 2: Упрощённый парсер JSON
### Постановка задачи  
• Написать функции для парсинга JSON-строки, представляющей набор параметров в формате ключ-значение
 (например, { "key1": "value1", "key2": 42 }).
 • Входные данные: JSON-строка.
 • Выходные данные: структура, содержащая массивы ключей и значений.
 • Использовать библиотеку cJSON для работы с JSON.

### Математическая модель
Отсутствует
### Список идентификаторов

### Код программы
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "cJSON.h"

typedef struct{
    char **keys;
    cJSON *values;
    int count;
} Pars;

//Функция для парсинга JSON-строки в структуру Pars
Pars* parse_json_pars(const char *json_str)
{
    if (json_str==NULL) return NULL;

    cJSON *json=cJSON_Parse(json_str);
    if (json==NULL || !cJSON_IsObject(json))
    {
        cJSON_Delete(json);
        return NULL;
    }
    Pars *pars=malloc(sizeof(Pars));
    if (!pars)
    {
        cJSON_Delete(json);
        return NULL;
    }

    int count=cJSON_GetArraySize(json);
    pars->count=count;
    pars->keys=malloc(sizeof(char*)*count);
    pars->values=malloc(sizeof(cJSON*)*count);
    if (!pars->keys || !pars->values)
    {
        free(pars->keys);
        free(pars->values);
        free(pars);
        cJSON_Delete(json);
        return NULL;
    }

    int i=0;
    cJSON *item=NULL;
    cJSON_ArrayForEach (item,json)
    {
        pars->keys[i]=strdup(item->string);//Копируем ключ
        pars->values[i]=item;//Сохраняем указатель на значение cJSON
        i++;
    }
    // Не удаляем json, т.к. values ссылаются на его элементы.
    // Освобождать нужно после использования Params.
    return pars;
}

//Функция очистки памяти Pars
void free_pars(Pars *pars)
{
    if(!pars) return;
    for (int i=0;i<pars->count;i++)
        free(pars->keys[i]);
    free (pars->keys);
    // Значения — это указатели на cJSON элементы,
    //освободить их нужно через cJSON_Delete верхнего объекта
}

int main(void)
{
    const char *json_str="{\"key1\": \"value1\",\"key2\":42}";
    Pars *pars=parse_json_pars(json_str);
    if(!pars)
    {
        printf("Ошибка парсинга JSON\n");
        return 1;
    }

    for (int i=0; i<pars->count;i++)
    {
        printf("Ключ %s, Значение: %s\n",pars->keys[i],cJSON_Print(pars->values[i]));
    }

    //Освобождение ресурсов
    if (pars->count>0)
    {
        // cJSON_Delete нужно вызвать для корня, чтобы освободить все значения
        cJSON *root=pars->values[0]->parent;
        while (root->parent)
            root =root->parent;//Подняться до корня элеменета
        cJSON_Delete(root);
    }
    free_pars(pars);

    return 0;

}
```
### Результаты
Подключить cJSON библиотеку так и не смогла. Использовала рекомендации https://www.perplexity.ai/search/cjson-lib-msys2-7L.zxfXmSi2W.BFHHxSEkQ , прошла все шаги инструкции, все необходимое используя MSYS установила.
Однако программа продолжает не видеть данный файл.

<img width="1122" height="142" alt="2" src="https://github.com/user-attachments/assets/ab361958-fe1a-439d-aafe-3d8fcce2a652" />

##  Задача 3: Решение систем линейных уравнений
### Постановка задачи:
 • Реализовать функцию для решения систем линейных уравнений методом Гаусса.
 • Параметры: массив коэффициентов и массив свободных членов.
 • Возвращать массив решений.
 • Поддержка работы с VLAи динамическими массивами
### Математическая модель
### Код программы
```c
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

// Функция решения системы линейных уравнений методом Гаусса
// params:
//   A - матрица коэффициентов (может быть VLA или динамической)
//   b - вектор свободных членов
//   n - размер системы
// возвращает массив решений (динамический массив)
double* gauss_solver(double** A, double* b, int n) {
    // Создаем копии A и b, чтобы не менять исходные данные
    double** mat = malloc(n * sizeof(double*));
    for (int i = 0; i < n; i++) {
        mat[i] = malloc(n * sizeof(double));
        for (int j = 0; j < n; j++) {
            mat[i][j] = A[i][j];
        }
    }
    double* vec = malloc(n * sizeof(double));
    for (int i = 0; i < n; i++) {
        vec[i] = b[i];
    }

    // Прямой ход (приведение к треугольному виду)
    for (int k = 0; k < n; k++) {
        // Поиск максимального по модулю элемента в k-ом столбце
        double max = fabs(mat[k][k]);
        int maxRow = k;
        for (int i = k + 1; i < n; i++) {
            if (fabs(mat[i][k]) > max) {
                max = fabs(mat[i][k]);
                maxRow = i;
            }
        }
        // Перестановка строк
        if (maxRow != k) {
            double* tmpRow = mat[k];
            mat[k] = mat[maxRow];
            mat[maxRow] = tmpRow;
            double tmpVal = vec[k];
            vec[k] = vec[maxRow];
            vec[maxRow] = tmpVal;
        }

        // Проверка на нулевой элемент на диагонали
        if (fabs(mat[k][k]) < 1e-15) {
            // Система либо вырождена, либо решения нет
            for (int i = 0; i < n; i++)
                free(mat[i]);
            free(mat);
            free(vec);
            return NULL;
        }

        // Исключение переменной k из уравнений ниже
        for (int i = k + 1; i < n; i++) {
            double coeff = mat[i][k] / mat[k][k];
            for (int j = k; j < n; j++) {
                mat[i][j] -= coeff * mat[k][j];
            }
            vec[i] -= coeff * vec[k];
        }
    }

    // Обратный ход (нахождение решения)
    double* x = malloc(n * sizeof(double));
    for (int i = n - 1; i >= 0; i--) {
        double sum = vec[i];
        for (int j = i + 1; j < n; j++) {
            sum -= mat[i][j] * x[j];
        }
        x[i] = sum / mat[i][i];
    }

    for (int i = 0; i < n; i++)
        free(mat[i]);
    free(mat);
    free(vec);

    return x;
}

int main() {
    int n = 3;
    double** A = malloc(n * sizeof(double*));
    for (int i = 0; i < n; i++) {
        A[i] = malloc(n * sizeof(double));
    }
    double b[] = {5, 9, 7};

    A[0][0] = 2; A[0][1] = 1; A[0][2] = -1;
    A[1][0] = -3; A[1][1] = -1; A[1][2] = 2;
    A[2][0] = -2; A[2][1] = 1; A[2][2] = 2;

    double* sol = gauss_solver(A, b, n);
    if (sol != NULL) {
        for (int i = 0; i < n; i++) {
            printf("x%d = %lf\n", i + 1, sol[i]);
        }
        free(sol);
    } else {
        printf("Решений нет или их бесконечно много.\n");
    }

    for (int i = 0; i < n; i++) {
        free(A[i]);
    }
    free(A);

    return 0;
}
```
### Результат

<img width="290" height="122" alt="3" src="https://github.com/user-attachments/assets/ab39ab8c-5bff-4674-984a-2c0739cae0bd" />

## Задача 5: Чтение веб-страницы
### Постановка задачи
 • Реализовать функцию для получения содержимого веб-страницы по URL.
 • Параметры: строка с URL.
 • Возвращать структуру, содержащую заголовки и тело ответа.
 • Использовать libcurl для выполнения HTTP-запросов.
 ### Математическая модель
 Отсутствует
### Код программы
