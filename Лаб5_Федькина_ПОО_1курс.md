# Лабораторная работа №5
## Тема лабораторной работы: Файловый ввод-вывод
##  Задача 1. Чтение и вывод содержимого текстового файла
### Постановка задачи:
Напишите программу, которая открывает текстовый файл (например, “input.txt”) для чтения, считывает его построч
но с помощью функции fgets() и выводит каждую строку на стандартный вывод. Программа должна проверять,
 успешно ли открыт файл, и корректно закрывать его после чтения
 ### Математическая модель
 Отсутствует
### Список идентификаторов
|Имя|Тип|Смысл|
|---|---|-----|
|*fp|FILE|Указатель на переменную типа FILE|
|buffer|char|Переменная, обозначающая пустую строку|
### Код программы 
```c
 #include <stdio.h>//подключение препроцессора ввод-вывод
 #include <stdlib.h>
    void readAndPrintFile() {//Функция для чтения и вывода файла
        FILE *fp = fopen("input.txt", "r");//указатель на переменную "типа" FILE кладется содержимое файла
        if (fp == NULL) {//Проверка: получилось ли прочитать файл
            perror("Ошибка открытия файла");
            exit(EXIT_FAILURE);//Безопасный выход из файла
            }
        char buffer[256];//Создание пустой строки, где будут храниться данные из файла
        while (fgets(buffer, sizeof(buffer), fp) != NULL) {//fgets(символьный массив, макс.длина строки, указатель на пер.типа FILE)
            printf("%s", buffer);
        }
        fclose(fp);//Закрытие файла
    }
 int main(void) {
    readAndPrintFile();
    return 0;   
 }
```
### Результат

<img width="326" height="93" alt="1" src="https://github.com/user-attachments/assets/76e086c5-0949-4a42-a5bc-710240c9b054" />

##  Задача 2. Запись пользовательского ввода в текстовый файл
### Постановка задачи:
 Создайте программу, которая запрашивает у пользователя несколько строк текста, а затем записывает введённые дан
ные в файл “output.txt”. Используйте режим записи "w". После завершения записи файл закрывается, а программа
 выводит сообщение об успешном завершении
 ### Математическая модель
 Отсутствует
### Список идентификаторов
|Имя|Тип|Смысл|
|---|---|-----|
|*fp|FILE|Указатель на переменную типа FILE|
|line|char|Переменная, обозначающая пустую строку|
### Код программы
```c
#include <stdio.h>
#include <stdlib.h>
void writeUserInputToFile() {//функция для записи данных в файл
    FILE *fp = fopen("output.txt", "w");//указатель на переменную типа FILE, создание пустого файлика
    if (fp == NULL) {//если не получилось создать файл (то есть в указетле нет адреса(ссылки) на новый файл, то выводим ошибку)
        perror("Ошибка создания файла");
        exit(EXIT_FAILURE);
    }
    char line[256];//создаем пустую строку, куда будем писать текст
    printf("Введите строки текста (для завершения введите пустую строку):\n");
    while (1) {//Бесконечный цикл (выполняется постоянно до тех пор, пока не будет встречен break) 
        fgets(line, sizeof(line), stdin);//stdin — это стандартный поток ввода. В него попадают все строки, вводимые пользователем. 
        // Если введена пустая строка (только символ новой строки), прекращаем ввод
        if (line[0] == '\n') break;
        fputs(line, fp);
    }
    fclose(fp);
    printf("Данные успешно записаны в output.txt\n");
 }
 int main(void) {
     writeUserInputToFile();
    return 0;
 }
```
### Результаты

<img width="696" height="166" alt="21" src="https://github.com/user-attachments/assets/9fa2690e-7c51-4360-ac3d-aa8f4937c19d" />

<img width="797" height="142" alt="22" src="https://github.com/user-attachments/assets/1f38051f-e7da-48d3-ac58-cefa135e9417" />


## Задача 3. Копирование содержимого одного файла в другой
### Постановка задачи:
Напишите программу, которая копирует содержимое файла “source.txt” в новый файл “destination.txt”. Программа
 должна открывать исходный файл в режиме чтения, а целевой — в режиме записи. Содержимое копируется блоками
 (например, по 256 байт) с использованием функций fread() и fwrite().
### Математическая модель
 Отсутствует
### Список идентификаторов
|Имя|Тип|Смысл|
|---|---|-----|
|*fp|FILE|Указатель на переменную типа FILE|
|line|char|Переменная, обозначающая пустую строку|
### Код программы
```c
 #include <stdio.h>
 #include <stdlib.h>
 void copyFile(const char *source, const char *destination) {//На вход программы подаются ссылки на файйд исходный и новый файл
    FILE *src = fopen(source, "rb");//( r — открыть файл для чтения (read),b — открыть файл в бинарном режиме (binary).)
    if (src == NULL) {//Проверка, открылся ли файл
        perror("Ошибка открытия исходного файла");
        exit(EXIT_FAILURE);
    }
    FILE *dest = fopen(destination, "wb");//w — открыть файл для написания (write),b — открыть файл в бинарном режиме (binary).
    if (dest == NULL) {//Проверка, создался ли файл
        perror("Ошибка создания файла назначения");
        fclose(src);
        exit(EXIT_FAILURE);
    }
    char buffer[256];//Пустая строка для ввода данных
    size_t bytes;
    while ((bytes = fread(buffer, 1, sizeof(buffer), src)) > 0) {//fread(массив, куда кладутся данные; размер каждого элемента в байтах:
        //max.кол-во для чтения; указатель на исходный файл)
        fwrite(buffer, 1, bytes, dest);//fwrite(массив, откуда берут данные; размер каждого эл.;кол-во символов в массиве;указатель на файл для записи)
    }
    fclose(src);
    fclose(dest);
    printf("Файл успешно скопирован из %s в %s\n", source, destination);
 }
 int main(void) {
    copyFile("source.txt", "destination.txt");
    return 0;
 }
```
### Результат

<img width="546" height="65" alt="31" src="https://github.com/user-attachments/assets/e71d1098-9863-466a-b6f8-3d1b1d340aab" />

<img width="393" height="130" alt="32" src="https://github.com/user-attachments/assets/8070a56f-0102-4a61-9dfe-f2f6e4ff81e7" />

<img width="375" height="102" alt="33" src="https://github.com/user-attachments/assets/c564cea2-649c-4732-9c41-1d6356f4ff68" />

## Задача 4. Подсчет строк, слов и символов в текстовом файле
### Постановка задачи
 Разработайте программу, которая открывает текстовый файл (например, “input.txt”) и подсчитывает:- количество
 строк (по числу символов новой строки),- количество слов (слова разделены пробелами и знаками препинания),
количество символов (включая пробелы).
 После подсчета программа выводит результаты
### Математическая модель
Отсутствует
### Список идентификаторов
|Имя|Тип|Смысл|
|---|---|-----|
|*fp|FILE|Указатель на переменную типа FILE|
|lines|int|Локальная перемнная, обозначающая кол-во строк|
|words|int|Локальная перемнная, обозначающая кол-во слов|
|chars|int|Локальная переменная, обозначающая кол-во символов|
|InWord|int|Локальная переменная-флаг, обозначающая слово еще "длиться" или уже закончилось|
|ch|char|Локальная перемeнная, обозначающая текущий символ|

### Код программы

```c
#include <stdio.h>
 #include <stdlib.h>
 #include <ctype.h>
 void countFileStats(const char *filename) {
    FILE *fp = fopen(filename, "r");//Открыть файл filename в режиме чтения 
    if (fp == NULL) {
        perror("Ошибка открытия файла");
        exit(EXIT_FAILURE);
    }
    int lines = 0;
    int words = 0;
    int chars = 0;//кол-во строчек, слов, символов
    int inWord = 0;
    int ch;//Каждый следующий символ
    while ((ch = fgetc(fp)) != EOF) {//ф-ция читает один символ (1 байт) из файла, на который указывает fp.
        //!EOF - не равен "End Of File" 
        chars++;
        printf("%d %c",chars,ch);
        if (ch == '\n')
            lines++;
        if (isspace(ch))//Это пробел?
            inWord = 0;
        else if (!inWord) {
            inWord = 1;
            words++;
        }
    }
    fclose(fp);
    printf("Строк: %d\nСлов: %d\nСимволов: %d\n", lines, words, chars);
 }
 int main(void) {
    countFileStats("input4.txt");
    return 0;
 }
```

### Результат
Эта программа способона считать корректно только строчки из латниских букв. На русских буквах происходит сбой (см. ниже)

<img width="437" height="137" alt="41" src="https://github.com/user-attachments/assets/1bd88106-3819-4ccc-8b52-65915fde2384" />

<img width="247" height="101" alt="42" src="https://github.com/user-attachments/assets/674350df-7f23-4cb7-8620-980023b68db2" />

<img width="206" height="82" alt="43" src="https://github.com/user-attachments/assets/3d01586b-6c3a-4a08-a5e0-00d985279cf7" />

<img width="733" height="148" alt="44" src="https://github.com/user-attachments/assets/2e4f7c4b-1269-4c6b-9978-fa3f3ac3f887" />

## Задача 5. Запись и чтение структур в бинарном файле
### Постановка задачи
 Определите структуру (например, struct Student с полями name, age и grade). Создайте массив таких структур,
 затем запишите его в бинарный файл с помощью fwrite(). После этого откройте файл для чтения и восстановите
 массив с помощью fread(), после чего выведите данные на экран.
### Математическая модель
Отсутствует
### Список идентификаторов
|Имя|Тип|Смысл|
|---|---|-----|
|*fp|FILE|Указатель на переменную типа FILE|
|studentsToWrite|struct Student|Экземляр структура Student|
|studentsToRead|struct Student|Пустой экземляр структура Student|

### Код программы
```c
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 struct Student {//Объявление структуры и ее создание
    char name[50];
    int age;
    float grade;
 };
 void writeStudents(const char *filename, struct Student students[], int count) {//Создание записи о студенте
    FILE *fp = fopen(filename, "wb");// "wb" - write binary
    if (fp == NULL) {
        perror("Ошибка создания бинарного файла");
        exit(EXIT_FAILURE);
    }
    fwrite(students, sizeof(struct Student), count, fp);//fwrite(массив, откуда берем данные,размер одного эл.массива,кол-во эл. в записи
    //указатель на файл, куда будет производиться запись)
    fclose(fp);
 }
 void readStudents(const char *filename, struct Student students[], int count) {//Чтение записи
    FILE *fp = fopen(filename, "rb");
    if (fp == NULL) {
        perror("Ошибка открытия бинарного файла");
        exit(EXIT_FAILURE);
    }
    fread(students, sizeof(struct Student), count, fp);
    fclose(fp);
 }
 int main(void) {
    struct Student studentsToWrite[2] = {//Экземляр структуры Student
    {"Иванов", 20, 4.5f},
    {"Петров", 22, 3.8f}
    };
    writeStudents("students.bin", studentsToWrite, 2);
    struct Student studentsRead[2];//Пустой экземляр, с помощью которого читаем данные
    readStudents("students.bin", studentsRead, 2);
    for (int i = 0; i < 2; i++) {
        printf("Студент: %s, Возраст: %d, Оценка: %.2f\n",
            studentsRead[i].name, studentsRead[i].age, studentsRead[i].grade);
    }
    return 0;
 }
```
### Результаты

<img width="432" height="107" alt="51" src="https://github.com/user-attachments/assets/2004d1a4-f5e8-4465-8271-98a0b2467971" />


<img width="212" height="82" alt="52" src="https://github.com/user-attachments/assets/ea245baa-e83b-4d72-b099-0b58d1c162d2" />

## Задача 6. Произвольный доступ к файлу с использованием fseek()
### Постановка задачи:
 Напишите программу, которая открывает бинарный файл с записями (например, структура из задачи 5). С помощью
 функции fseek() переместитесь к определённой записи (например, к записи с индексом 1), измените её данные и
 запишите изменения в файл. Затем прочитайте файл заново и выведите изменённую запись.
### Математическая модель
Отсутствует
### Список идентификаторов
|Имя|Тип|Смысл|
|---|---|-----|
|*fp|FILE|Указатель на переменную типа FILE|
|students|struct Student|Экземляр структура Student|
|newRecord|struct Student|Новая запись структуры Student|

### Код программы
```c
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 struct Student {// Создание структуры
    char name[50];
    int age;
    float grade;
 };
 void updateStudentRecord(const char *filename, int index, struct Student newData) {
    FILE *fp = fopen(filename, "rb+");//rb+ - открытие библиотеки для чтения и записи
    if (fp == NULL) {
        perror("Ошибка открытия файла");
        exit(EXIT_FAILURE);
    }
 // Перемещаемся к нужной записи:
    fseek(fp, index * sizeof(struct Student), SEEK_SET);//fseek(рабочий файл, индекс, в который хотим переместиться
    //умноженный на размер элементаб SEEK_SET(указатель на начало файла. Создан для возможности перемещаться)
    fwrite(&newData, sizeof(struct Student), 1, fp);//fwrite(указатель на новую запись, размера структуры Student,
    // кол-во элементов для записи, куда пишем)
    fclose(fp);
}
 void printStudentRecord(const char *filename, int index) {
   FILE *fp = fopen(filename, "rb");//rb -  открыт для чтения
    if (fp == NULL) {
        perror("Ошибка открытия файла");
        exit(EXIT_FAILURE);
    }
    struct Student s;
    fseek(fp, index * sizeof(struct Student), SEEK_SET);
    fread(&s, sizeof(struct Student), 1, fp);
    fclose(fp);
    printf("Обновлённая запись: %s, %d, %.2f\n", s.name, s.age, s.grade);
 }
 int main(void) {
 // Исходный массив записей (как в задаче 5)
    struct Student students[2] = {
        {"Иванов", 20, 4.5f},
        {"Петров", 22, 3.8f}
    };
 // Записываем в файл
    FILE *fp = fopen("students.bin", "wb");
    if (fp == NULL) {
        perror("Ошибка создания файла");
        exit(EXIT_FAILURE);
    }
    fwrite(students, sizeof(struct Student), 2, fp);
    fclose(fp);
    // Обновляем вторую запись (индекс 1)
    struct Student newRecord = {"Петров", 23, 4.2f};
    updateStudentRecord("students.bin", 1, newRecord);
 // Выводим обновленную запись
    printStudentRecord("students.bin", 1);
    return 0;
 }
```
### Результаты

<img width="347" height="87" alt="6" src="https://github.com/user-attachments/assets/c1bd996f-47fc-4ee8-81b8-3e306e06e283" />

##  Задача 7. Использование временного файла (temporary file)
### Постановка задачи
 Разработайте программу, которая создает временный файл с помощью функции tmpfile(), записывает в него
 несколько строк (например, результаты промежуточных вычислений или лог), затем перемещается в начало файла с
 помощью fseek(), считывает содержимое и выводит его на экран. Временный файл автоматически удаляется после
 закрытия.
### Математическая модель
Отсутствует
### Список идентификаторов
|Имя|Тип|Смысл|
|---|---|-----|
|*fp|FILE|Указатель на переменную типа FILE|
|buffer|char|Строка выводимых данных|

### Код программы
```c
 #include <stdio.h>
 #include <stdlib.h>
 void tempFileDemo() {
    FILE *fp = tmpfile();//Создание временного файла
    if (fp == NULL) {
        perror("Ошибка создания временного файла");
        exit(EXIT_FAILURE);
    }
 // Запись данных во временный файл
    fprintf(fp, "Строка 1: Пример работы с tmpfile()\n");
    fprintf(fp, "Строка 2: Временный файл будет удален после закрытия\n");
 // Перемещаемся в начало файла
    fseek(fp, 0, SEEK_SET);
 // Считываем и выводим содержимое файла
    char buffer[256];
    while (fgets(buffer, sizeof(buffer), fp) != NULL) {
        printf("%s", buffer);
    }
    fclose(fp); // Временный файл удаляется автоматически
 }
 int main(void) {
    tempFileDemo();
    return 0;
 }
```
### Результаты

<img width="508" height="122" alt="7" src="https://github.com/user-attachments/assets/3c83c6d3-4137-4857-b3cc-d8544984a989" />

## Информация о себе
Федькина Полина Дмитриевна, 1 курс, ПОО



