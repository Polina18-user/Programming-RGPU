# Rust Лабораторная работа #2
## Задача №1
### Постановка задачи
 Создайте структуру Pair<T>, которая хранит два значения одного типа T. Реализуйте ме
 тоды для получения и изменения значений пары. Убедитесь, что использование ссылок и
 копирование данных работает корректно.
### Математическая модель
Отсутствует
### Список идентификаторов
|Имя|Тип|Смысл|
|---|---|-----|
|pair|struct Pair|переменная, экземпляр структуры Pair с целочисленными значениями|
|a|неизменяемый|переменная, неизменяемая ссылка на первое значение|
|b|неизменяемый|переменная, неизменяемая ссылка на второе значение|
|a_mut|изменяемые|переменная, изменяемая ссылка на первое значение|
|b_mut|изменяемые|переменная, изменяемая ссылка на второе значение|
### Код программы
```c
#[derive(Debug, Clone, Copy)]
struct Pair<T> {
    first: T,
    second: T,
}

impl<T> Pair<T> {
    // Конструктор
    fn new(first: T, second: T) -> Self {
        Pair { first, second }
    }

    // Получить ссылки на значения пары
    fn get(&self) -> (&T, &T) {
        (&self.first, &self.second)
    }

    // Изменить значения пары через мутабельные ссылки
    fn get_mut(&mut self) -> (&mut T, &mut T) {
        (&mut self.first, &mut self.second)
    }

    // Можно добавить методы для установки новых значений напрямую
    fn set(&mut self, first: T, second: T) {
        self.first = first;
        self.second = second;
    }
}

fn main() {
    let mut pair = Pair::new(10, 20);

    // Получаем ссылки на значения
    let (a, b) = pair.get();
    println!("Первое: {}, Второе: {}", a, b);

    // Модифицируем значения через мутабельные ссылки
    let (a_mut, b_mut) = pair.get_mut();
    *a_mut = 15;
    *b_mut = 25;
    println!("Изменённые значения: {:?}", pair);

    // Заменяем значения напрямую
    pair.set(100, 200);
    println!("Новые значения после set: {:?}", pair);
}
```

### Результат

<img width="765" height="115" alt="1" src="https://github.com/user-attachments/assets/b756dce6-3a4f-4cb7-a2a4-314572737f0c" />

## Задача №2
### Постановка задачи
 Определите трейт PrintInfo, который содержит метод print_info(&self). Реализуйте этот
 трейт для структуры Person, чтобы можно было вызвать метод print_info на объекте Person.
### Математическая модель
Отсутствует
### Список идентификаторов
|Имя|Тип|Смысл|
|---|---|-----|
|person|struct Person|переменная, экземпляр структуры Person|

### Код программы
```c
// Определяем трейт PrintInfo с методом print_info
trait PrintInfo {
    fn print_info(&self);
}

// Структура Person
struct Person {
    name: String,
    age: u32,
}

// Реализуем трейт PrintInfo для Person
impl PrintInfo for Person {
    fn print_info(&self) {
        println!("Имя: {}, Возраст: {}", self.name, self.age);
    }
}

fn main() {
    let person = Person {
        name: String::from("Иван"),
        age: 30,
    };

    // Вызываем метод из трейта
    person.print_info();
}
```
### Результат

<img width="400" height="81" alt="2" src="https://github.com/user-attachments/assets/6fc7544d-6c94-4832-9561-367baad5914b" />


## Задача №3
### Постановка задачи
Разработайте программу для обработки списка задач (Todo List). Создайте структуру Task с
полями id, title и completed, а также методы для добавления, удаления и изменения статуса
задачи. Реализуйте вывод информации о всех задачах.
### Математическая модель
Отсутствует
### Список идентификаторов
|Имя|Тип|Смысл|
|---|---|-----|
|todo_list|struct TodoList|переменная, экземпляр структуры TodoList|

### Код программы
```c
#[derive(Debug)]
struct Task {
    id: usize,
    title: String,
    completed: bool,
}

impl Task {
    fn new(id: usize, title: String) -> Self {
        Task {
            id,
            title,
            completed: false,
        }
    }

    fn toggle_completed(&mut self) {
        self.completed = !self.completed;
    }
}

struct TodoList {
    tasks: Vec<Task>,
    next_id: usize,
}

impl TodoList {
    fn new() -> Self {
        TodoList {
            tasks: Vec::new(),
            next_id: 1,
        }
    }

    //Добавить задачу
    fn add_task(&mut self, title: String) {
        let task = Task::new(self.next_id, title);
        self.tasks.push(task);
        self.next_id += 1;
    }
//Удалить задачу по id
    fn remove_task(&mut self, id: usize) -> bool {
        if let Some(pos) = self.tasks.iter().position(|x| x.id == id) {
            self.tasks.remove(pos);
            true
        } else {
            false
        }
    }
//Изменить статус
    fn toggle_task_status(&mut self, id: usize) -> bool {
        if let Some(task) = self.tasks.iter_mut().find(|x| x.id == id) {
            task.toggle_completed();
            true
        } else {
            false
        }
    }
//Вывести все задачи
    fn print_tasks(&self) {
        for task in &self.tasks {
            println!(
                "[{}] {} - {}",
                if task.completed { "x" } else { " " },
                task.id,
                task.title
            );
        }
    }
}

fn main() {
    let mut todo_list = TodoList::new();

    todo_list.add_task("Сделать домашнее задание".into());
    todo_list.add_task("Прочитать книгу".into());
    todo_list.print_tasks();

    println!("\n--- После изменения статуса задачи с id = 1 ---");
    todo_list.toggle_task_status(1);
    todo_list.print_tasks();

    println!("\n--- После удаления задачи с id = 2 ---");
    todo_list.remove_task(2);
    todo_list.print_tasks();
}
```
### Результат

<img width="631" height="283" alt="3" src="https://github.com/user-attachments/assets/db78b157-98b2-4c87-bc55-4a47e5d97ff3" />

## Задача №4
### Постановка задачи:
Напишите функцию find_unique_elements, которая принимает вектор элементов типа T и
 возвращает вектор уникальных элементов. Определите трейт Unique c методом is_unique,
 который проверяет, является ли элемент уникальным.
### Математическая модель
Отсутсвует
### Список идентификаторов
|Имя|Тип|Смысл|
|---|---|-----|
|v|vec|Вектор значений|
|unique|-|Вектор уникальных значений|
### Код программы
```c
use std::collections::HashMap;
use std::hash::Hash;

// Трейт, который проверяет, является ли элемент уникальным
pub trait Unique {
    fn is_unique(&self, all: &[Self]) -> bool where Self: Sized;
}

// Имплементация трейта Unique для всех типов, которые поддерживают Eq + Hash + Clone
impl<T> Unique for T
where
    T: Eq + Hash + Clone,
{
    fn is_unique(&self, all: &[Self]) -> bool {
        all.iter().filter(|&x| x == self).count() == 1
    }
}

// Функция, которая возвращает вектор уникальных элементов
pub fn find_unique_elements<T>(vec: Vec<T>) -> Vec<T>
where
    T: Unique + Clone,
{
    vec.iter()
        .filter(|&item| item.is_unique(&vec))
        .cloned()
        .collect()
}

// Пример использования
fn main() {
    let v = vec![1, 2, 2, 3, 4, 4, 5];
    let unique = find_unique_elements(v);
    println!("{:?}", unique); // Выведет [1, 3, 5]
}
```
### Результат

<img width="451" height="97" alt="4" src="https://github.com/user-attachments/assets/c42a0e70-7ef2-4a87-a461-a34791b8758d" />

## Задача №5
### Постановка задачи:
Напишите функцию sum_collection, которая принимает коллекцию элементов типа T и
 возвращает их сумму. Ограничьте тип T требованием наличия метода addition() в некото
 ром трейте Addable для поддержки суммирования. Просуммируйте затем любую коллекцию
 структур вида:
 struct Number {
 value: u32,
 }
### Математическая модель
Отсутствует
### Список идентификаторов
|Имя|Тип|Смысл|
|---|---|-----|
|other||параметр метода addition, второй операнд сложения|
|collection||параметр функции, срез коллекции элементов|
|self||параметр методов, ссылка на текущий объект|
|sum||переменная для накопления суммы в функции sum_collection|
|item||переменная итератора в цикле for|
|numbers||переменная вектора чисел в функции main|
|result||переменная для хранения результата суммирования|

### Код программы
```c
trait Addable {
    fn addition(&self, other: &Self) -> Self;
}
#[derive(Clone)]
struct Number {
    value: u32,
}

impl Addable for Number {
    fn addition(&self, other: &Self) -> Self {
        Number { value: self.value + other.value }
    }
}

fn sum_collection<T: Addable + Clone>(collection: &[T]) -> Option<T> {
    if collection.is_empty() {
        return None;
    }
    let mut sum = collection[0].clone();
    for item in &collection[1..] {
        sum = sum.addition(item);
    }
    Some(sum)
}

fn main() {
    let numbers = vec![
        Number { value: 10 },
        Number { value: 20 },
        Number { value: 30 },
    ];

    if let Some(result) = sum_collection(&numbers) {
        println!("Сумма: {}", result.value);
    } else {
        println!("Коллекция пуста");
    }
}
```
### Результат

<img width="887" height="193" alt="5" src="https://github.com/user-attachments/assets/134e75b4-8054-4782-b09c-0037d12a8878" />

## Задача 6
### Постановка задачи
Создайте обобщенную структуру Collection<T>, которая содержит вектор элементов типа
 T. Реализуйте методы add_element(), get_element() и remove_element(), ограничив тип T
 trait’ом Clone:
 • https://doc.rust lang.org/std/clone/trait.Clone.html
 • https://doc.rust lang.org/rustbyexample/trait/clone.html
 • https://doc.rust lang.org/std/clone/index.html
 • https://oswalt.dev/2023/12/copyandcloneinrust/
 • https://blog.logrocket.com/disambiguatingrust traitscopyclonedynamic/
### Математическая модель
Отсутствует
### Список идентификаторов
|Имя|Тип|Смысл|
|---|---|-----|
|mut self|Ссылка mut|параметр, изменяемая ссылка на экземпляр структуры|
|self|Ссылка||параметр, неизменяемая ссылка на экземпляр структуры|
|element||параметр, элемент для добавления в коллекцию|
|index||параметр, индекс элемента коллекции|
|collection|struct Collection|переменная, экземпляр структуры Collection|
|self||ключевое слово, ссылка на текущий экземпляр структуры|

### Код программы
```c
#[derive(Debug)]
struct Collection<T: Clone> {
    elements: Vec<T>,
}

impl<T: Clone> Collection<T> {
    fn new() -> Self {
        Collection {
            elements: Vec::new(),
        }
    }

    fn add_element(&mut self, element: T) {
        self.elements.push(element);
    }

    fn get_element(&self, index: usize) -> Option<T> {
        self.elements.get(index).cloned()
    }

    fn remove_element(&mut self, index: usize) -> Option<T> {
        if index < self.elements.len() {
            Some(self.elements.remove(index))
        } else {
            None
        }
    }
}

fn main() {
    let mut collection = Collection::new();

    collection.add_element(10);
    collection.add_element(20);
    collection.add_element(30);

    println!("Element at index 1: {:?}", collection.get_element(1));
    println!("Removed element at index 0: {:?}", collection.remove_element(0));
    println!("Collection after removal: {:?}", collection.elements);
}
```
### Результаты

<img width="452" height="122" alt="6" src="https://github.com/user-attachments/assets/7af3f000-d242-4177-999f-1b1f8909a8cf" />

## Задача №7
### Постановка задачи
Создайте трейт Summable, который требует реализации метода sum(&self)-> u32 для типов,
 поддерживающих сложение. Реализуйте этот трейт для структуры Pair<T>, которая содержит
 два поля типа T (сумма чисел в этой паре). Добавьте ограничение на тип T для поддержки
 сложения:
 • https://doc.rust lang.org/book/ch1903advancedtraits.html
 • https://doc.rust lang.org/std/ops/trait.Add.html
 • https://doc.rust lang.org/std/ops/index.html
 • https://stackoverflow.com/questions/28005134/howdoi implement theaddtrait fora
 referencetoastruct
 • https://doc.rust lang.org/book/ch1002traits.html#implementingatraitonatype
 • https://doc.rust lang.org/book/appendix03derivabletraits.html
### Математическая модель
Отсутствует
### Список иденитификаторов

### Код программы
```c
use std::ops::Add;

trait Summable {
    fn sum(&self) -> u32;
}

struct Pair<T> {
    a: T,
    b: T,
}

impl<T> Summable for Pair<T>
where
    T: Add<Output = T> + Into<u32> + Copy,
{
    fn sum(&self) -> u32 {
        (self.a + self.b).into()
    }
}

fn main() {
    let pair = Pair { a: 10u8, b: 20u8 };
    println!("Sum: {}", pair.sum());  // Выведет Sum: 30
}
```
### Результат

<img width="872" height="181" alt="7" src="https://github.com/user-attachments/assets/afcaf801-54c5-48f4-b51c-9d709fb68784" />

## Информация о студенте
Федькина Полина Дмитриевна, ПОО, 1 курс.
