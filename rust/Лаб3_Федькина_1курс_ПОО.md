# Лабораторная работа №3
## Цель:
Целью данной лабораторной работы является практическое освоение ключевых концепций языка программирова
ния Rust путем создания полноценного консольного приложения. В процессе выполнения работы студенты научатся
 применять коллекции, модульную систему, обработку ошибок, систему сборки Cargo, организацию ввода-вывода и
 познакомятся с небезопасным кодом
 ## Задание
 Разработать консольное приложение “Система управления студенческой библиотекой”, которое позволяет:
 • Добавлять книги в каталог
 • Регистрировать читателей
 • Выдавать книги читателям
 • Принимать возврат книг
 • Просматривать списки книг и читателей
 • Сохранять и загружать данные из файла
 ## Теоретические сведения
 Перед началом работы необходимо понимать следующие концепции:
 1. Коллекции в Rust — это структуры данных для хранения множества элементов. Основные коллекции: Vec<T> (ди
намический массив), HashMap<K, V> (хеш-таблица для хранения пар ключ-значение), String (строка в UTF-8).
 2. Модульная система позволяет разбивать программу на логические части. Ключевое слово mod объявляет модуль,
 use импортирует элементы, pub делает элементы публичными.
 3. Обработка ошибок в Rust реализуется через типы Result<T, E> (для операций, которые могут завершиться ошиб
кой) и Option<T> (для значений, которые могут отсутствовать). Оператор ? автоматически распространяет ошибки.
 4. Cargo —это менеджер пакетов и система сборки Rust. Файл Cargo.toml описывает проект и его зависимости.
 5. Ввод-вывод осуществляется через модуль std::io. Функция stdin() возвращает дескриптор стандартного ввода,
 метод read_line() читает строку.
 6. Unsafe Rust позволяет обходить некоторые проверки компилятора для выполнения низкоуровневых операций, таких
 как работа с сырыми указателями
## Порядок выполнения работы
### Шаг 1: Создание проекта.
### Результат:

<img width="1392" height="250" alt="1 0" src="https://github.com/user-attachments/assets/f03e35b2-10e9-488b-9717-245ccc7dad2b" />


<img width="417" height="112" alt="1 1" src="https://github.com/user-attachments/assets/40b52a87-98c8-4a47-9367-9cdfb7895aac" />


<img width="603" height="246" alt="1 2" src="https://github.com/user-attachments/assets/6eb72ea3-1232-4335-b195-dfca1149616a" />

### Шаг 2: Добавление зависимостей.
### Результат:

<img width="580" height="282" alt="2" src="https://github.com/user-attachments/assets/7cb82016-ac6b-444d-8fa6-47341f88baa6" />

### Шаг 3: Создание модуля моделей данных
### Результат:

<img width="593" height="457" alt="3" src="https://github.com/user-attachments/assets/8c545a0e-761c-45c8-af21-23039546e6d7" />


###  Шаг 4: Создание основной библиотеки
### Результат:

<img width="217" height="173" alt="4-5" src="https://github.com/user-attachments/assets/5f1a0f25-17a3-4e9a-b359-fd5abe89e95b" />


<img width="925" height="701" alt="4" src="https://github.com/user-attachments/assets/9ba9595a-614b-478c-a9f0-61f0ce8ebc0c" />

### Шаг 5: Создание главного файла с интерактивным меню
### Результат:

<img width="217" height="173" alt="4-5" src="https://github.com/user-attachments/assets/418e33f5-5948-4e9b-814d-74e415d878cf" />


<img width="917" height="697" alt="5" src="https://github.com/user-attachments/assets/06b138bd-5870-4b5e-b669-a5a241ffe496" />


### Шаг 6: Сборка изапуск проекта
### Результат:

<img width="931" height="328" alt="6 1" src="https://github.com/user-attachments/assets/8d4a5325-b3bd-4177-bc59-6a4d78ac2d10" />

### Шаг 7: Тестирование приложения
### Результат:

<img width="691" height="347" alt="7 0" src="https://github.com/user-attachments/assets/f63c5ca2-ea02-41b2-9b39-6cee4547e43b" />

<img width="837" height="442" alt="7 1" src="https://github.com/user-attachments/assets/580f18a3-c301-48b2-b6d9-7277bff5a0a9" />

<img width="705" height="407" alt="7 2" src="https://github.com/user-attachments/assets/a24ea04b-3537-4385-9e0f-422c7e7b28ef" />

<img width="890" height="505" alt="7 3" src="https://github.com/user-attachments/assets/929c5bed-9b36-4b54-896e-1ce5baf94e23" />

<img width="557" height="162" alt="7 4" src="https://github.com/user-attachments/assets/bfa65856-cddf-44f1-b5b5-b7bd40c186a4" />

<img width="531" height="442" alt="7 5" src="https://github.com/user-attachments/assets/a4060129-1666-4879-aa1b-7d6a7e5a2142" />

<img width="548" height="398" alt="7 6" src="https://github.com/user-attachments/assets/4fbbbcac-ba18-4e11-a6bb-d3f9ce83a72b" />

<img width="815" height="661" alt="7 7" src="https://github.com/user-attachments/assets/32b44ce7-f1c0-469f-8f55-c813aec6346e" />

## Контрольные вопросы:
#### Вопрос 1:  Объясните разницу между Vec<T> и HashMap<K, V>. Почему для книг используется Vec, а для читателей HashMap?
Ответ:  Vec используется для хранения книг:
- Позволяетдинамическидобавлятьэлементы-Обеспечиваетпоследовательный
 доступ
- Метод push() добавляет элемент в конец
- Метод iter_mut() создает изменяемый итератор
 HashMap<u32,Reader>используется для читателей:
- Обеспечиваетбыстрыйпоискпоключу(ID)
- Метод insert() добавляет пару ключ-значение
- Метод contains_key() проверяет наличие ключа
- Метод get() возвращает ссылку на значение
#### Вопрос 2:  Что произойдет, если убрать pub перед struct Book в файле models.rs?
Ответ:  pub struct Book—публичная структура (доступна из других модулей). Если убрать pub структура перестанет быть публичной, следовательно, она перестанет
быть доступна другим модулям, возникнет ошибка
#### Вопрос 3:  Как работает оператор ? в функции borrow_book()? Что произойдет, если заменить его на unwrap()?
- Оператор ? автоматически возвращает ошибку из функции, если результат Err. Это позволяет функции аккуратно завершить выполнение и сообщить вызывающему коду ошибку.
- Метод unwrap() же неявно вызывает panic, если результат Err. То есть при возникновении ошибки программа аварийно завершит работу (паниковать), вместо того, чтобы вернуть ошибку вызывающему коду.
- То есть такая замена приведет к небезопасному завершению программы, что не есть хорошо.
### Вопрос 4: Почему в Cargo.toml для serde указано features = ["derive"]?
- serde — библиотека для сериализации/десериализации данных- features = ["derive"] — вклю
чает макросы для автоматической генерации кода- serde_json — реализация формата JSON для serde
### Вопрос 5: Объясните цепочку вызовов: io::stdin().read_line(&mut input).expect("Ошибка")
io::stdin() - создает объект стандартного потока ввода с клавиатуры
read_line(&mut input) - читает одну строку из ввода и записывает в переменную input.
Ключевое слово &mut говорит об изменяемости передаваемой ссылки.
expect("Ошибка") - если  во время чтения возникнет ошибка, то программа аварийно прекратит работу и выведет сообщение об ошибке.
### Вопрос 6: Что делает метод flush() и почему он важен при выводе приглашений ввода?
 flush() гарантирует, что приглашение отобразится до ввода.
 Если не вызвать flush(), приглашение может не отобразиться до момента, когда пользователь уже должен ввести данные, что может сбивать с толку.
### Вопрос 7:  Зачем нужен блок unsafe в функции show_library_memory_address()?
 Функция show_library_memory_address() демонстрирует работу с сырыми указателями.  Блок unsafe необходим, так как компилятор не может гарантировать безопасность операций с сырыми указателями.
### Вопрос 8: Как serde_json преобразует структуру Library в JSON? Какие трейты для этого нужны?
- serde_json использует макросы и реализации трейта Serialize, чтобы рекурсивно "перебрать" все поля структуры и преобразовать их в соответствующие JSON-объекты, массивы и примитивы.
- Поля структур преобразуются в пары ключ-значение, где ключ — имя поля, а значение — его содержимое в формате JSON.
- Если внутри структуры есть вложенные структуры, они тоже должны реализовывать Serialize.
Необходимые трейты: Serialize, Deserialize
Сериализация: serde_json::to_string_pretty() преобразует структуру в JSON-строку
Десериализация: serde_json::from_str() преобразует JSON-строку обратно в структуру
### Вопрос 9:  Что произойдет, если при запуске приложения файл library.json будет поврежден?
Выдаст ошибку и не продолжит свою работу
### Вопрос 10: Объясните, почему метод add_book() возвращает ссылку &Book, а не владеющий тип Book. 
Применяется ссылка, а не владеющий тип, чтобы:
1. Избежать копирования и клонирования
2. Связь с внутренними состоянием структуры
3. Безопаснее
## Задачи для самостоятельного выполнения
###  Задание 1 (базовый уровень)
### Постановка задачи:
Добавьте поле year: u32 (год издания) в структуру Book и отобразите его в списке книг.
### Код:
Что я изменила:
1. в models.rs добавила поле year

```
pub struct Book{
    pub id:u32,
    pub title: String,
    pub author: String,
    pub is_available: bool,
    pub year: u32,
}
```
3. В main.rs в функцию fn add_book добавила ввод year

```
    io::stdout().flush().unwrap();
    let year_input = read_line();
    let year: u32 = year_input.trim().parse().expect("Ошибка при вводе года");

   let book = library.add_book(title, author,year);
    println!("� Книга '{}' (автор: {}, год: {}) успешно добавлена с ID {}.",
        book.title, book.author,book.year, book.id);
```

   И доавила в графичекую табличку, котоая выводится пользователю на экран соответсвующие столбики и выровняла их
   ```
   println!("│ {:2} │ {:<16} │{:<12}│{:<10}│{:<14}│",
        book.id,
        truncate(&book.title, 24),
        truncate(&book.author, 20),
        book.year,
        status);
   ```
5. В lib.rs
```
 pub fn add_book(&mut self, title: String, author: String,year:u32)-> &Book {
    let new_book = Book {
        id: self.next_book_id,
        title,
        author,
        year,
        is_available: true,
    };
```

### Результат

<img width="867" height="962" alt="з1" src="https://github.com/user-attachments/assets/f50d05bd-e12f-423f-9dda-2f8383da2fb5" />

###  Задание 2 (средний уровень)
### Постановка задачи:
Реализуйте функцию поиска книг по названию (частичное совпадение, без учета регистра)
### Код:
1. В main.rs
```
   // Функция для нахождения книги по слову/символу
fn find_book(library: &Library) {
    println!("\n--- Поиск книги---");
    print!("Введите символ/ы: ");
    io::stdout().flush().unwrap();
    
    let answer = read_line().trim().to_string();
    if answer.is_empty() {
        println!("Ошибка: невозможно найти книгу.");
        return;
    }
    
    let ans_res = answer.to_lowercase();
    
    let found_books: Vec<_> = library.get_books() // обращаемся к полю с книгами
        .iter()
        .filter(|book| book.title.to_lowercase().contains(&ans_res))
        .collect();
    
    // Вывод результатов
    if found_books.is_empty() {
        println!("Книги по запросу '{}' не найдены", answer);
    } else {
        println!("Найдено книг по запросу '{}': {}", answer, found_books.len());
        for book in found_books {
            println!("- {} (автор: {}, год: {})", book.title, book.author, book.year);
        }
    }
}
```

2. В lib.rs - сделали поле books pub

### Результат

<img width="952" height="947" alt="з2" src="https://github.com/user-attachments/assets/73382fd9-e29b-4c43-8bf8-173fe3b1e226" />

К сожалению, остальное я не придумала как решать, хотя я много чего перепробовала(
### Информация о студенте:
Федькина Полина Дмитриевна, ПОО, 1 курс

