# Тема лабораторной работы: Лабораторная работа #1. Указатели
## Задача 1- упражнения с malloc и сложными однострочными выражениями в C с присваиваниями внутри.
### Постановка задачи:
 Внутри функции int main(void) { /*...*/ } определите указатель:
 double ***pointer = NULL;
 Инициализируйте этот указатель адресом другого указателя типа double **, который указывает, в свою очередь, на
 переменную double. Используйте pointer для записи и чтения в эту переменную значения 2.
 При этом выполните следующее:- Используйте функции типа *alloc(...) для выделения оперативной памяти под
 динамические объекты;- Запишите и выведите число 2 на экран, используя указатель double ***pointer = NULL;;- Используйте функцию free(...) для освобождения оперативной памяти, выделенной под динамические объекты.- Не используйте никаких идентификаторов переменных, кроме point
### Список идентификаторов
| Имя переменной | Тип данных | Описание |
|----------------|------------|----------|
| ***pointer     | double     |Указатель|
|pointer         |double ***  |Указатель|
|*pointer        |double **   |Указатель|
|**pointer       |double *    |Указатель|
### Код программы
```C
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    double ***pointer = NULL;

    pointer = (double ***) malloc(sizeof(double **));
    if (pointer == NULL) return 1;

    *pointer = (double **) malloc(sizeof(double *));
    if (*pointer == NULL) 
    { 
        free(pointer); 
        return 1;
     }

    **pointer = (double *) malloc(sizeof(double));
    if (**pointer == NULL) 
    { 
        free(*pointer); 
        free(pointer); 
        return 1; 
    }

    ***pointer = 2.0;

    printf("%g\n", ***pointer);

    free(**pointer);
    free(*pointer);
    free(pointer);

    return 0;
}
```
### Результат
<img width="347" height="147" alt="Л1" src="https://github.com/user-attachments/assets/f73fbd05-3ef9-43c6-8c65-f3d63b100525" />

##  Задача 2- итерация массива с помощью арифметики указателей
### Постановка задачи:
 Напишитепрограмму, которая создает одномерный динамический массив из чисел с плавающей точкой двойной точ
ности, заполняет его значениями с клавиатуры и выводит все элементы массива, используя арифметику указателей
 (оператор +), а не оператор доступа к элементам массива []
### Список идентификаторов
| Имя переменной | Тип данных |           Описание       |
|----------------|------------|--------------------------|
| nBlock         | int        |Кол-во элементов в массиве|
| *Buffer        |double      |       Указатель          |
|*i              |double      |       Указатель          |
### Код программы
```C
#include <stdio.h>
#include <stdlib.h>
int main (void)
{
    int nBlock=0;
    double *Buffer=NULL;
    double *i=NULL;
    
     printf("Введите количество элементов в массиве:\n");
    scanf("%d",&nBlock);

    if(nBlock<=0)
    {
        printf("ERROR");
        return 1;
    }
    Buffer=malloc(nBlock*sizeof(double));
    if (Buffer==NULL)
    {
        printf("Не удалось выделить память!!!");
        return 1;
    }
    for (i=Buffer;i<Buffer+nBlock;++i)
    {
        printf("Введите элемент массива:\n");
        if (scanf("%lf",i)!=1)
        {
            printf("ERROR ввода!!!");
            free(Buffer);
            return 1;
        }
    }
    printf("Получившийся массив: \n");
    for (i=Buffer;i<Buffer+nBlock;++i)
    {
        printf("%lf\n",*i);
    }
    free(Buffer);
    return 0;
}
```
### Результат
<img width="508" height="398" alt="Л2" src="https://github.com/user-attachments/assets/827c5e66-661c-448b-bc44-d005efdc49b6" />

## Задача 3.1- динамический 2D массив.
### Постановка задачи:
 Выделите память под двумерный динамический массив двумя способами:
 1. Классический способ: выделите память для массива указателей на строки и отдельно для каждой строки в
 цикле. Это позволит гибко управлять памятью, но при этом каждая строка будет находиться в отдельной части
 памяти.
 После выполнения программы обязательно корректно освободите всю выделенную оперативную память с помощью
 free().
 Обаметодаимеютсвоипреимуществаинедостатки.Принепрерывномвыделении(contiguousallocation)всяпамять
 выделяется в одном блоке, что уменьшает вероятность фрагментации, но может усложнить управление при необхо
димости изменения размеров массива

### Список идентификаторов
| Имя переменной | Тип данных | Описание      |
|----------------|------------|---------------|
| str            | int        |  Кол-во строк |
| stlb           | int        |Кол-во столбцов|
|**arr           |int         |Указатель|

### Код программы
```C
#include <stdio.h>
#include<stdlib.h>
int main(void)
{
    int str,stlb;
    int **arr=NULL;
    printf("Введите кол-во строк:\n");
    scanf("%d",&str);
    printf("Введите кол-во столбцов:\n");
    scanf("%d",&stlb);

    arr=(int **) malloc (str*sizeof(int*));
    if (arr==NULL)
    {
        printf("ERROR!!");
        return 1;
    }
    for (int i=0;i<str;i++)
    {
        arr[i]=(int *)malloc (stlb*sizeof(int));
    }
    for (int i=0;i<str;i++)
    {
        for (int j=0;j<stlb;j++)
        {
            printf("Введите элементы массива по строкам (то есть сначала те элементы которые будут в 1 строке, и т.д.\n");
            scanf("%d",&arr[i][j]);

        }
    }
    for (int i=0;i<str;i++)
    {
        for (int j=0;j<stlb;j++)
        {
            printf("%d ",arr[i][j]);
        }
        printf("\n");
    }
    for (int i=0;i<str;i++)
    {
        free(arr[i]);
    }
    free(arr);
    return 0;
}
```
### Результат
<img width="930" height="698" alt="Л3" src="https://github.com/user-attachments/assets/ffe8024e-4e50-46e7-af6e-537d80ff902c" />

## Задача 3.2- динамический 2D массив.
### Постановка задачи:
 Выделите память под двумерный динамический массив двумя способами
 2. Непрерывный способ (contiguous memory allocation): выделите память для всего массива одним вызовом
 malloc, что позволит разместить весь массив в непрерывном блоке памяти, улучшая производительность и
 снижая риск внешней фрагментации памяти.
 После выполнения программы обязательно корректно освободите всю выделенную оперативную память с помощью
 free().
 Обаметодаимеютсвоипреимуществаинедостатки.Принепрерывномвыделении(contiguousallocation)всяпамять
 выделяется в одном блоке, что уменьшает вероятность фрагментации, но может усложнить управление при необхо
димости изменения размеров массива
### Список идентификаторов
| Имя переменной | Тип данных | Описание      |
|----------------|------------|---------------|
| str            | int        |  Кол-во строк |
| stlb           | int        |Кол-во столбцов|
|**arr           |int         |Указатель      |
|elem            | int        |Элемент массива|
### Код программы
```C
#include <stdio.h>
#include <stdlib.h>
int main(void)
{
    int str,stlb;
    int elem;
    printf("Введите кол-во строк:\n");
    scanf("%d",&str);
    printf("Введите кол-во столбцов:\n");
    scanf("%d",&stlb);
    void *arr=malloc(str*sizeof(int*)+str*stlb*sizeof(int));
    if (arr==NULL)
    {
        printf("Проблемы с памятью!");
        return 1;
    }
    int **a=(int**)arr;
    int *data=(int*)((char*)arr+str*sizeof(int*));
    for (int i=0;i<str;++i)
    {
        a[i]=data+i*stlb;
    }
    for (int i=0;i<str;++i)
    {
        for (int j=0;j<stlb;++j)
        {
            printf("Введите элемент массива: \n");
            scanf("%d",&elem);
            a[i][j]=elem;
        }
    }
    for (int i=0;i<str;++i)
    {
        for (int j=0;j<stlb;++j)
        {
            printf("%d ",a[i][j]);
        }
        printf("\n");
    }
    
    free(arr);
    return 0;
}
```
### Результат
<img width="413" height="681" alt="Л32" src="https://github.com/user-attachments/assets/622b3a9b-d6cc-4ba0-bb3d-1c4f1f8aad32" />

##  Задача 4- поменять местами два числа через указатели
### Постановка задачи:
 Написать программу, которая использует функцию для обмена значениями двух переменных через указатели
### Список идентификаторов
| Имя переменной | Тип данных | Описание             |
|----------------|------------|----------------------|
| a              | int        |Первое число          |
| b              |int         |Второе число          |
| n(в функции)   |int         |Времнно хранит данные |
|*pa             |int         |Указатель             |
|*pb             |int         |Указатель             |
Остальные переменные - локальные (указанные в функциях)
### Код программы
```C
#include <stdio.h>
#include <stdlib.h>
void perestav(int *a,int *b)
{
    int n=*a;
    *a=*b;
    *b=n;
}
int main(void)
{
    int a,b;
    printf("Введите a: \n");
    scanf("%d",&a);
    printf("Введите b: \n");
    scanf("%d",&b);
    int *pa,*pb;
    pa=&a;
    pb=&b;
    perestav(pa,pb);
    printf("a= %d \n",a);
    printf("b= %d",b);
    return 0;
}

```
### Результат
<img width="391" height="271" alt="Л4" src="https://github.com/user-attachments/assets/2c21c0db-4385-45a2-94fd-f95530efe691" />

##  Задача 5- поиск максимального элемента массива с помощью указателей
### Постановка задачи:
 Создать функцию, которая принимает массив целых чисел и его размер, а затем возвращает указатель на максималь
ный элемент массива
### Список идентификаторов
| Имя переменной | Тип данных | Описание    |
|----------------|------------|-------------|
| n              | int        |Длина массива|
|arr             |int         |Массив       |
|*mx             |int         |Указатель    |
|*elem           |int         |Указатель    |
### Код программы
```C
#include <stdio.h>

int *rabota_ms(int *arr,int n)
{
    if (arr==NULL||n==0)
    {
        printf("ERROR!\n");
        return NULL;
    }

    int *elem=arr;
    for (int i=1;i<n;++i)
    {
        if (arr[i]>*elem)
        {
            elem=&arr[i];
        }
    }
    return elem;
}
int main (void)
{
    int n=5;
    int arr[5]={0,1,2,3,4};
    int *mx=rabota_ms(arr,n);

    if (mx!=NULL)
    {
        printf("Максимальный элемент массива равен %d. ",*mx);
    }
    else
    {
        printf ("ERROR!\n");
    }
    return 0;
}
```
### Результат
<img width="407" height="160" alt="Л5" src="https://github.com/user-attachments/assets/a3095736-17d3-4e20-a8d0-eaf290465deb" />

##  Задача 6- реверс массива через указатели
### Постановка задачи:
 Реализовать функцию, которая переворачивает массив целых чисел, используя указатели для перемещения по эле
ментам.
### Список идентификаторов
| Имя переменной | Тип данных |         Описание    |
|----------------|------------|---------------------|
| n              | int        |Длина массива        |
|arr             |int         |Массив               |
|* x             |int         |Указатель            |
|*y              |int         |Указатель            |
|elem            |int         |Временно хранит числа|
### Код программы
```C
#include <stdio.h>
void reverse(int *arr,int n)
{
    if (arr==NULL || n<=1)
    {
        return;
    }
    int *x=arr;//указатель на начало
    int *y=arr+n-1;// указатель на конец

    while (x<y)
    {
        int elem=*x;
        *x=*y;
        *y=elem;
        x++;
        y--;
    }
}

int main(void)
{
    int n=5;
    int arr[5]={0,1,2,3,4};
    printf("Массив: \n");
    for (int i=0;i<n;++i)
    {
        printf("%d ",arr[i]);
    }
    printf("\n");

    reverse(arr,n);
    printf("Новый массив: \n");
    for (int i=0;i<n;++i)
    {
        printf("%d ",arr[i]);
    }
    printf("\n");
    return 0;

}
```
### Результат
<img width="347" height="223" alt="Л6" src="https://github.com/user-attachments/assets/5efa5d37-0030-4dd2-938e-4ffb586fb5e1" />

##  Задача 9- подсчет числа пробелов в строке
### Постановка задачи:
 Написать функцию, которая подсчитывает количество пробелов в строке, используя указатели для перемещения по
 символам строки.
### Список идентификаторов
| Имя переменной | Тип данных |      Описание        |
|----------------|------------|----------------------|
| *st            | char       |  Указатель           |
|s               |char        |      Строка          |
|count           |int         |Кол-во пробелов       |
|k               |int         |Счётчик в ф-ции       |
|elem            |cha         |Временно хранит символ|
### Код программы
```C
#include <stdio.h>
#include <string.h>
int probel(char *s)
{
    char *st=s;
    int k=0;
    if (st==NULL)
    {
        return 0;
    }
    while (*st!='\0')
    {
        char elem=*st;
        if (elem==' ')
        {
            k=k+1;
        }
        st++;
    }
    return k;
}
int main(void)
{
    char s[100];
    fgets(s,100,stdin);
    int count=probel(s);
    printf ("Количество пробелов строке: %d \n",count);
    return 0;
}
```
### Результат
<img width="528" height="238" alt="Л9" src="https://github.com/user-attachments/assets/32c77be5-782a-4cd1-be50-47413f1f759e" />

## Информация об обучающемся: Федькина Полина Дмитриевна 1 курс ПОО.
